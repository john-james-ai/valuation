{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Discounted Cash Flow (DCF) Valuation Tutorial\n",
    "\n",
    "## Overview\n",
    "\n",
    "This notebook walks through the complete process of performing a **Discounted Cash Flow (DCF) valuation** for a retail company using historical financial statements and revenue forecasts.\n",
    "\n",
    "### What is DCF Valuation?\n",
    "\n",
    "DCF is a valuation method that estimates the value of an investment based on its expected future cash flows. The core principle is:\n",
    "\n",
    "**Enterprise Value = Present Value of Future Free Cash Flows**\n",
    "\n",
    "### Key Concepts\n",
    "\n",
    "1. **Free Cash Flow (FCF)**: Cash generated by the business after accounting for capital expenditures\n",
    "   - FCF = NOPAT - CapEx - Change in Net Working Capital\n",
    "   \n",
    "2. **Weighted Average Cost of Capital (WACC)**: The discount rate representing the company's cost of capital\n",
    "\n",
    "3. **Terminal Value**: The value of all cash flows beyond the explicit forecast period\n",
    "\n",
    "4. **Enterprise Value (EV)**: The total value of the business\n",
    "   - EV = PV(Forecast Period FCFs) + PV(Terminal Value)\n",
    "\n",
    "5. **Equity Value**: Value to shareholders\n",
    "   - Equity Value = Enterprise Value - Net Debt\n",
    "\n",
    "### Workflow\n",
    "\n",
    "1. Load financial statements and revenue forecasts\n",
    "2. Aggregate revenue to company level\n",
    "3. Convert to annual projections\n",
    "4. Calculate Free Cash Flows\n",
    "5. Calculate Terminal Value\n",
    "6. Calculate Enterprise Value\n",
    "7. Bridge to Equity Value\n",
    "8. Perform Sensitivity Analysis\n",
    "9. Visualize Results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Setup & Imports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from datetime import datetime\n",
    "from loguru import logger\n",
    "import warnings\n",
    "\n",
    "# Import your custom modules\n",
    "from valuation.analysis.financials import Financials\n",
    "from valuation_dcf import ValuationDCF\n",
    "\n",
    "warnings.filterwarnings('ignore')\n",
    "sns.set_style('whitegrid')\n",
    "\n",
    "# Configure logger\n",
    "logger.remove()  # Remove default handler\n",
    "logger.add(\n",
    "    lambda msg: print(msg, end=''),\n",
    "    format=\"{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {message}\",\n",
    "    level=\"INFO\"\n",
    ")\n",
    "\n",
    "print(\"✓ Imports complete\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Load Financial Statements\n",
    "\n",
    "We start by loading the company's historical financial statements from their 1997 10-K filing. The `Financials` dataclass contains:\n",
    "\n",
    "- **Income Statement**: Revenue, COGS, Operating Income, Net Income\n",
    "- **Balance Sheet**: Assets, Liabilities, Equity, Working Capital\n",
    "- **Cash Flow Statement**: Operating, Investing, and Financing Activities\n",
    "- **Financial Ratios**: Profitability, Liquidity, Leverage, Efficiency\n",
    "\n",
    "These metrics will be used to calibrate our DCF assumptions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Initialize Financials object with 1997 data\n",
    "financials_1997 = Financials()\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"FINANCIAL STATEMENTS LOADED (FY 1997)\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "# Display key metrics\n",
    "print(f\"\\nRevenue: ${financials_1997.revenue:,.0f}\")\n",
    "print(f\"Net Income: ${financials_1997.net_income:,.0f}\")\n",
    "print(f\"Total Assets: ${financials_1997.total_assets:,.0f}\")\n",
    "print(f\"\\nKey Ratios:\")\n",
    "print(f\"  Gross Margin: {financials_1997.gross_profit_margin:.2f}%\")\n",
    "print(f\"  Operating Margin: {financials_1997.operating_margin:.2f}%\")\n",
    "print(f\"  EBITDA Margin: {financials_1997.ebitda_margin:.2f}%\")\n",
    "print(f\"  Current Ratio: {financials_1997.current_ratio:.2f}\")\n",
    "print(f\"  Debt to Equity: {financials_1997.debt_to_equity_ratio:.2f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Load Revenue Forecasts\n",
    "\n",
    "The DCF valuation requires projections of future revenues. We'll load pre-generated forecasts that cover the period from 1997-2002.\n",
    "\n",
    "These forecasts are typically generated using:\n",
    "- Time series models (ARIMA, Prophet, ML models)\n",
    "- Hierarchical reconciliation methods\n",
    "- Bottom-up aggregation from store/category level\n",
    "\n",
    "**Note**: You'll need to replace this with your actual forecast data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load revenue forecasts\n",
    "# Replace with your actual forecast file path\n",
    "forecast_df = pd.read_csv(\"forecasts_5year_1997_2002.csv\")\n",
    "forecast_df['ds'] = pd.to_datetime(forecast_df['ds'])\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"REVENUE FORECASTS LOADED\")\n",
    "print(\"=\"*80)\n",
    "print(f\"\\nShape: {forecast_df.shape}\")\n",
    "print(f\"Date Range: {forecast_df['ds'].min()} to {forecast_df['ds'].max()}\")\n",
    "print(f\"Unique Series: {forecast_df['unique_id'].nunique()}\")\n",
    "print(f\"\\nColumns: {list(forecast_df.columns)}\")\n",
    "\n",
    "# Display sample\n",
    "print(\"\\nSample Data:\")\n",
    "print(forecast_df.head())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Select Forecast Model\n",
    "\n",
    "If multiple forecast models are available (e.g., base forecasts and reconciled forecasts), we need to select which one to use for valuation.\n",
    "\n",
    "**Best Practice**: Use reconciled forecasts when available as they ensure coherence across the hierarchy."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Identify available forecast columns\n",
    "model_cols = [col for col in forecast_df.columns \n",
    "              if col not in ['unique_id', 'ds', 'level']]\n",
    "\n",
    "print(f\"\\nAvailable forecast models: {model_cols}\")\n",
    "\n",
    "# Select forecast column (modify as needed)\n",
    "if 'LGBMRegressor/MinTrace_method-ols' in model_cols:\n",
    "    FORECAST_COL = 'LGBMRegressor/MinTrace_method-ols'\n",
    "    print(f\"✓ Using reconciled forecast: {FORECAST_COL}\")\n",
    "elif 'LGBMRegressor' in model_cols:\n",
    "    FORECAST_COL = 'LGBMRegressor'\n",
    "    print(f\"✓ Using base forecast: {FORECAST_COL}\")\n",
    "else:\n",
    "    FORECAST_COL = model_cols[0]\n",
    "    print(f\"⚠️  Using first available: {FORECAST_COL}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Initialize DCF Valuation Model\n",
    "\n",
    "Now we initialize our `ValuationDCF` class with:\n",
    "\n",
    "1. **Financial statements** - to calibrate assumptions\n",
    "2. **Revenue forecasts** - the basis for cash flow projections\n",
    "3. **Valuation date** - typically beginning of forecast period\n",
    "4. **Terminal assumptions** - for perpetuity growth method\n",
    "\n",
    "The model will automatically extract key metrics from the financials:\n",
    "- Operating margin\n",
    "- Tax rate\n",
    "- CapEx as % of revenue\n",
    "- Working capital requirements"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set valuation parameters\n",
    "VALUATION_DATE = pd.Timestamp('1997-01-01')\n",
    "TERMINAL_GROWTH_RATE = 0.03  # 3% perpetual growth (GDP + inflation)\n",
    "TERMINAL_FCF_MULTIPLE = 12   # Alternative exit multiple\n",
    "\n",
    "# Initialize DCF model\n",
    "dcf = ValuationDCF(\n",
    "    financials=financials_1997,\n",
    "    forecast_df=forecast_df,\n",
    "    forecast_col=FORECAST_COL,\n",
    "    valuation_date=VALUATION_DATE,\n",
    "    wacc=None,  # Will be calculated from financials\n",
    "    terminal_growth_rate=TERMINAL_GROWTH_RATE,\n",
    "    terminal_fcf_multiple=TERMINAL_FCF_MULTIPLE,\n",
    "    net_debt=0,  # Update with actual net debt if available\n",
    "    minority_interest=0,\n",
    "    other_adjustments=0\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Step-by-Step Valuation Process\n",
    "\n",
    "We'll walk through each step of the DCF process to understand how revenue forecasts are converted to enterprise value."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.1 Aggregate Revenue to Company Level\n",
    "\n",
    "If forecasts are at the store-category level, we need to aggregate them to total company revenue to avoid double-counting."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Aggregate to weekly company revenue\n",
    "weekly_revenue = dcf.aggregate_revenue()\n",
    "\n",
    "# Visualize weekly revenue trend\n",
    "plt.figure(figsize=(14, 5))\n",
    "plt.plot(weekly_revenue['ds'], weekly_revenue['revenue'] / 1000, \n",
    "         color='steelblue', alpha=0.7, linewidth=1.5)\n",
    "plt.title('Weekly Revenue Forecast (1997-2002)', fontsize=14, fontweight='bold')\n",
    "plt.xlabel('Date')\n",
    "plt.ylabel('Revenue ($K)')\n",
    "plt.grid(alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "print(f\"\\nTotal 5-Year Revenue: ${weekly_revenue['revenue'].sum():,.0f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.2 Convert to Annual Revenue\n",
    "\n",
    "DCF models typically use annual periods. We aggregate weekly forecasts to fiscal years."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Convert to annual revenue\n",
    "annual_revenue = dcf.convert_to_annual()\n",
    "\n",
    "# Visualize annual revenue\n",
    "plt.figure(figsize=(10, 5))\n",
    "plt.bar(annual_revenue['year'], annual_revenue['revenue'] / 1_000_000, \n",
    "        color='steelblue', alpha=0.7, edgecolor='navy')\n",
    "plt.title('Annual Revenue Forecast', fontsize=14, fontweight='bold')\n",
    "plt.xlabel('Year')\n",
    "plt.ylabel('Revenue ($M)')\n",
    "plt.grid(axis='y', alpha=0.3)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Calculate year-over-year growth\n",
    "annual_revenue['yoy_growth'] = annual_revenue['revenue'].pct_change() * 100\n",
    "print(\"\\nAnnual Revenue & Growth:\")\n",
    "print(annual_revenue.to_string(index=False))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.3 Build DCF Model - Calculate Free Cash Flows\n",
    "\n",
    "For each year, we calculate:\n",
    "\n",
    "1. **EBIT** = Revenue × Operating Margin\n",
    "2. **NOPAT** = EBIT × (1 - Tax Rate)\n",
    "3. **CapEx** = Revenue × CapEx %\n",
    "4. **Change in NWC** = ΔRevenue × NWC %\n",
    "5. **FCF** = NOPAT - CapEx - ΔNWC\n",
    "6. **PV of FCF** = FCF / (1 + WACC)^t"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Build complete DCF model\n",
    "dcf_model = dcf.build_dcf_model()\n",
    "\n",
    "# Display the model\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"DCF MODEL - FREE CASH FLOW PROJECTIONS\")\n",
    "print(\"=\"*80)\n",
    "display_cols = ['year', 'revenue', 'ebit', 'nopat', 'capex', \n",
    "                'nwc_change', 'fcf', 'discount_factor', 'pv_fcf']\n",
    "print(dcf_model[display_cols].to_string(index=False))\n",
    "\n",
    "# Visualize FCF components for final year\n",
    "last_year = dcf_model.iloc[-1]\n",
    "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n",
    "\n",
    "# FCF waterfall\n",
    "components = ['NOPAT', 'CapEx', 'NWC Δ', 'FCF']\n",
    "values = [\n",
    "    last_year['nopat'] / 1_000_000,\n",
    "    -last_year['capex'] / 1_000_000,\n",
    "    -last_year['nwc_change'] / 1_000_000,\n",
    "    last_year['fcf'] / 1_000_000\n",
    "]\n",
    "colors = ['green', 'red', 'red', 'darkgreen']\n",
    "ax1.bar(range(len(components)), values, color=colors, alpha=0.7, edgecolor='black')\n",
    "ax1.set_xticks(range(len(components)))\n",
    "ax1.set_xticklabels(components)\n",
    "ax1.set_title(f'FCF Components ({int(last_year[\"year\"])})', fontweight='bold')\n",
    "ax1.set_ylabel('Amount ($M)')\n",
    "ax1.axhline(y=0, color='black', linestyle='-', linewidth=0.5)\n",
    "ax1.grid(axis='y', alpha=0.3)\n",
    "\n",
    "# Annual FCF trend\n",
    "colors = ['green' if x > 0 else 'red' for x in dcf_model['fcf']]\n",
    "ax2.bar(dcf_model['year'], dcf_model['fcf'] / 1_000_000, \n",
    "        color=colors, alpha=0.7, edgecolor='black')\n",
    "ax2.set_title('Annual Free Cash Flow', fontweight='bold')\n",
    "ax2.set_xlabel('Year')\n",
    "ax2.set_ylabel('FCF ($M)')\n",
    "ax2.axhline(y=0, color='black', linestyle='-', linewidth=0.5)\n",
    "ax2.grid(axis='y', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.4 Calculate Terminal Value\n",
    "\n",
    "The terminal value represents all cash flows beyond our explicit forecast period. We use the **Perpetuity Growth Model**:\n",
    "\n",
    "$$TV = \\frac{FCF_{terminal} \\times (1 + g)}{WACC - g}$$\n",
    "\n",
    "Where:\n",
    "- FCF_terminal = Final year free cash flow (2002)\n",
    "- g = Terminal growth rate (typically 2-3%)\n",
    "- WACC = Weighted average cost of capital\n",
    "\n",
    "The terminal value is then discounted back to present value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate terminal value\n",
    "terminal_value, pv_terminal_value = dcf.calculate_terminal_value()\n",
    "\n",
    "print(f\"\\nTerminal Value: ${terminal_value:,.0f}\")\n",
    "print(f\"PV of Terminal Value: ${pv_terminal_value:,.0f}\")\n",
    "\n",
    "# Show terminal value calculation details\n",
    "terminal_fcf = dcf_model.iloc[-1]['fcf']\n",
    "g = dcf.assumptions['terminal_growth_rate']\n",
    "wacc = dcf.assumptions['wacc']\n",
    "\n",
    "print(f\"\\nTerminal Value Calculation:\")\n",
    "print(f\"  Terminal FCF (2002): ${terminal_fcf:,.0f}\")\n",
    "print(f\"  Growth Rate: {g:.1%}\")\n",
    "print(f\"  WACC: {wacc:.2%}\")\n",
    "print(f\"  Formula: {terminal_fcf:,.0f} × (1 + {g:.1%}) / ({wacc:.2%} - {g:.1%})\")\n",
    "print(f\"  Result: ${terminal_value:,.0f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.5 Calculate Enterprise Value\n",
    "\n",
    "Enterprise Value is the sum of:\n",
    "1. Present value of forecast period free cash flows (1997-2002)\n",
    "2. Present value of terminal value\n",
    "\n",
    "$$EV = \\sum_{t=1}^{n} \\frac{FCF_t}{(1 + WACC)^t} + \\frac{TV}{(1 + WACC)^n}$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate enterprise value\n",
    "enterprise_value = dcf.calculate_enterprise_value()\n",
    "\n",
    "# Value breakdown\n",
    "pv_forecast = dcf_model['pv_fcf'].sum()\n",
    "forecast_pct = pv_forecast / enterprise_value * 100\n",
    "terminal_pct = pv_terminal_value / enterprise_value * 100\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"ENTERPRISE VALUE CALCULATION\")\n",
    "print(\"=\"*80)\n",
    "print(f\"\\nPV of Forecast Period (1997-2002): ${pv_forecast:,.0f} ({forecast_pct:.1f}%)\")\n",
    "print(f\"PV of Terminal Value:              ${pv_terminal_value:,.0f} ({terminal_pct:.1f}%)\")\n",
    "print(f\"{'-'*80}\")\n",
    "print(f\"ENTERPRISE VALUE:                   ${enterprise_value:,.0f}\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "# Visualize value composition\n",
    "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n",
    "\n",
    "# Bridge chart\n",
    "bridge_labels = ['Forecast\\nPeriod', 'Terminal\\nValue', 'Enterprise\\nValue']\n",
    "bridge_values = [pv_forecast / 1_000_000, pv_terminal_value / 1_000_000, 0]\n",
    "colors = ['purple', 'orange', 'darkgreen']\n",
    "ax1.bar(range(len(bridge_labels)), bridge_values, color=colors, \n",
    "        alpha=0.7, edgecolor='black')\n",
    "ax1.axhline(y=enterprise_value / 1_000_000, color='green', \n",
    "           linestyle='--', linewidth=2, label='Total EV')\n",
    "ax1.set_xticks(range(len(bridge_labels)))\n",
    "ax1.set_xticklabels(bridge_labels)\n",
    "ax1.set_title('Enterprise Value Bridge', fontweight='bold')\n",
    "ax1.set_ylabel('Value ($M)')\n",
    "ax1.legend()\n",
    "ax1.grid(axis='y', alpha=0.3)\n",
    "\n",
    "# Pie chart\n",
    "ax2.pie([forecast_pct, terminal_pct], labels=['Forecast Period', 'Terminal Value'],\n",
    "        autopct='%1.1f%%', colors=['purple', 'orange'], startangle=90)\n",
    "ax2.set_title('Value Composition', fontweight='bold')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5.6 Bridge to Equity Value\n",
    "\n",
    "To get from Enterprise Value to Equity Value, we adjust for:\n",
    "\n",
    "$$Equity\\ Value = EV - Net\\ Debt - Minority\\ Interest + Other\\ Adjustments$$\n",
    "\n",
    "Where:\n",
    "- Net Debt = Total Debt - Cash\n",
    "- Minority Interest = Non-controlling interests\n",
    "- Other Adjustments = Pensions, off-balance sheet items, etc."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate equity value\n",
    "equity_value = dcf.calculate_equity_value()\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"EQUITY VALUE CALCULATION\")\n",
    "print(\"=\"*80)\n",
    "print(f\"\\nEnterprise Value:        ${enterprise_value:,.0f}\")\n",
    "print(f\"Less: Net Debt:          ${dcf.net_debt:,.0f}\")\n",
    "print(f\"Less: Minority Interest: ${dcf.minority_interest:,.0f}\")\n",
    "print(f\"Add: Other Adjustments:  ${dcf.other_adjustments:,.0f}\")\n",
    "print(f\"{'-'*80}\")\n",
    "print(f\"EQUITY VALUE:            ${equity_value:,.0f}\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "# If you have shares outstanding, calculate price per share\n",
    "# shares_outstanding = 1_000_000  # Example\n",
    "# price_per_share = equity_value / shares_outstanding\n",
    "# print(f\"\\nImplied Share Price: ${price_per_share:.2f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Sensitivity Analysis\n",
    "\n",
    "DCF valuations are sensitive to key assumptions. We test how the enterprise value changes with different:\n",
    "- **WACC** (discount rate)\n",
    "- **Terminal Growth Rate**\n",
    "\n",
    "This creates a sensitivity table showing the range of possible valuations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run sensitivity analysis\n",
    "sensitivity_df = dcf.run_sensitivity_analysis()\n",
    "\n",
    "# Create sensitivity table\n",
    "sensitivity_table = sensitivity_df.pivot(\n",
    "    index='terminal_growth',\n",
    "    columns='wacc',\n",
    "    values='enterprise_value'\n",
    ") / 1_000_000  # Convert to millions

# Visualize sensitivity
plt.figure(figsize=(12, 8))
sns.heatmap(sensitivity_table, annot=True, fmt='.1f', cmap='RdYlGn', 
            cbar_kws={'label': 'Enterprise Value ($M)'}, linewidths=0.5)
plt.title('Enterprise Value Sensitivity Analysis\\nRows: Terminal Growth Rate | Columns: WACC', 
          fontsize=14, fontweight='bold', pad=20)
plt.xlabel('WACC', fontweight='bold')
plt.ylabel('Terminal Growth Rate', fontweight='bold')
plt.tight_layout()
plt.show()

# Calculate sensitivity ranges
base_ev = dcf.enterprise_value / 1_000_000
min_ev = sensitivity_table.min().min()
max_ev = sensitivity_table.max().max()

print(f"\\nEnterprise Value Range:\")\nprint(f\"  Base Case: ${base_ev:.1f}M\")\nprint(f\"  Minimum:   ${min_ev:.1f}M ({(min_ev/base_ev - 1)*100:+.1f}%)\")\nprint(f\"  Maximum:   ${max_ev:.1f}M ({(max_ev/base_ev - 1)*100:+.1f}%)\")\nprint(f\"  Range:     ${max_ev - min_ev:.1f}M\")"